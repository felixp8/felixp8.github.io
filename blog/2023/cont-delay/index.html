<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>approximation of discrete delays with continuous-time dynamics | Felix Pei</title> <meta name="author" content="Felix Pei"> <meta name="description" content="some pointless and basic math noodling"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://felixp8.github.io/blog/2023/cont-delay/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Felix Pei</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">approximation of discrete delays with continuous-time dynamics</h1> <p class="post-meta">November 27, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> math</a>   <a href="/blog/tag/code"> <i class="fa-solid fa-hashtag fa-sm"></i> code</a>     ·   <a href="/blog/category/dynamical-systems"> <i class="fa-solid fa-tag fa-sm"></i> dynamical-systems</a>   <a href="/blog/category/wip"> <i class="fa-solid fa-tag fa-sm"></i> wip</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In discrete-time dynamical systems, it’s easy to create a state variable that is a time-delayed copy of another. For example, if we have a linear system</p> \[\begin{bmatrix} x_1(t + 1) \\ x_2(t + 1) \\ x_3(t + 1) \end{bmatrix} = A \cdot \begin{bmatrix} x_1(t) \\ x_2(t) \\ x_3(t) \end{bmatrix}\] <p>and we want \(x_3\) to be equal to \(x_1\), but delayed by one timestep, we can design A as</p> \[A = \begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\ a_{21} &amp; a_{22} &amp; a_{23} \\ 1 &amp; 0 &amp; 0 \end{bmatrix}\] <p>so that \(x_3(t + 1) = x_1(t)\). Of course, we can only ever create delays of exactly one timestep, and to achieve greater delays we’d need to chain multiple variables each delayed by a timestep. More generally, in discrete-time systems, state variables can only affect each other with a one timestep delay.</p> <p>In continuous-time systems, state variables affect each other instantaneously. It is therefore not obvious how to recreate this sort of time-delayed relationship between variables, though this occurs often in real-world systems, e.g. in interacting brain regions. This problem has been extensively studied in a variety of fields, but because I am too lazy to look into it, I just messed around a bit myself and found a solution that is probably known already and/or useless.</p> <h3 id="problem-statement">Problem statement</h3> <p>Let me try to state the problem a little more clearly. We have a continuous-time dynamical system</p> \[\dot{x} = f(x,u)\] <p>where \(x \in \mathbb{R}^{N}\). We want to make some sort of coupled dynamical system with a new state variable \(y\) so that \(y(t) = x_{i}(t - \tau)\) for some index \(i \in [1, N]\) and some delay \(\tau &gt; 0\). This means that we want</p> \[\dot{y}(t) = \dot{x}_{i}(t - \tau).\] <p>In theory, we could maintain an entire delayed copy of \(x\) and compute \(\dot{x}_{i}(t - \tau)\) just from \(f\), but this is generally impractical because:</p> <ol> <li>We’d need to also store all external inputs \(u(t)\) for \([t - \tau, t]\).</li> <li>We’d need to initialize this copied system exactly to \(x(t - \tau)\). Otherwise, any errors in the initialization will remain for the entire simulation.</li> </ol> <p>Instead, if we could estimate \(\dot{x}_{i}(t - \tau)\) purely from observables at time \(t\) and allow for some margin of error in initializing \(y\), that would be potentially less accurate but more useful.</p> <h3 id="prior-work-finite-differences">Prior work: finite differences</h3> <p>Though I didn’t do much research on prior work, I did look at the first search result<sup id="fnref:fn1" role="doc-noteref"><a href="#fn:fn1" class="footnote" rel="footnote">1</a></sup>. The method proposed there is very simple: approximate</p> \[\dot{x}_{i}(t - \tau) \approx \dot{y}(t) = \frac{x_{i}(t) - y(t)}{\tau}.\] <p>If \(y(t) = x_{i}(t - \tau)\) exactly, then the estimate is equal to</p> \[\frac{x_{i}(t) - x_{i}(t - \tau)}{\tau},\] <p>which converges to \(\dot{x}_{i}(t - \tau)\) as \(\tau \to 0\).</p> <p>As you can imagine, this becomes less accurate for larger \(\tau\), so instead of going straight for \(\tau\), you can break up the delay into many smaller intervals where each derivative estimate is likely to be more accurate. The resulting system would look something like this:</p> \[\dot{x} = f(x,u)\] \[\dot{y}_1 = (x_i - y_1) / \Delta t\] \[\dot{y}_2 = (y_1 - y_2) / \Delta t\] \[...\] \[\dot{y}_m = (y_{m-1} - y_m) / \Delta t\] <p>which gives a total delay of \(m \cdot \Delta t\) for \(y_m\). If it helps to see it in matrix form, the above could also be written like this:</p> \[\begin{bmatrix} \dot{x} \\ \dot{y}_1 \\ \\ \vdots \\ \\ \dot{y}_m \end{bmatrix} = \begin{bmatrix} f_{lin} &amp; 0 &amp; &amp; \dots &amp; &amp; 0 \\ 1/\Delta t &amp; -1/\Delta t &amp; 0 &amp; &amp; \dots &amp; \\ 0 &amp; 1/\Delta t &amp; -1/\Delta t &amp; &amp; \dots &amp; \\ &amp; &amp; \ddots &amp; \ddots &amp; &amp; \\ &amp; &amp; &amp; \ddots &amp; \ddots &amp; \\ 0 &amp; &amp; \dots &amp; &amp; 1/\Delta t &amp; -1/\Delta t \end{bmatrix} \begin{bmatrix} x \\ y_1 \\ \\ \vdots \\ \\ y_m \end{bmatrix} + \begin{bmatrix} 1 \\ 0 \\ \\ \vdots \\ \\ 0 \end{bmatrix} f_{nonlin}(x,u)\] <p>where \(f_{lin}\) is whatever component of \(f\) can be represented as a linear function of \(x\) and \(f_{nonlin}\) is everything else. (My weird notation of \(f_{lin}\) and \(f_{nonlin}\) is irrelevant though - the main idea is the rest of the matrix!)</p> <p>There are a few nice things about this method:</p> <ol> <li>The dynamics of the delayed variables do not depend explicitly on the inputs at all. Instead, they account for the effect of the inputs only by looking at \(x_{i}\) directly.</li> <li>The system sort of self-corrects for inaccurate initializations. If \(\Delta t\) is small enough, we can assume that all gradient estimates are accurate when \(y\) values are accurate. Then, for example, if \(y\) is initialized too small, the gradient estimate from the finite difference will be bigger than the true gradient, which compensates for the initialization error.</li> </ol> <p>The method can be extended/improved with central differences<sup id="fnref:fn1:1" role="doc-noteref"><a href="#fn:fn1" class="footnote" rel="footnote">1</a></sup> or unevenly-spaced \(y\) points<sup id="fnref:fn2" role="doc-noteref"><a href="#fn:fn2" class="footnote" rel="footnote">2</a></sup>, which may give better accuracy.</p> <p>Lastly, notice that if our integration timestep is also \(\Delta t\), then \(\Delta t \cdot \pm 1 / \Delta t = \pm 1\), and we have recreated the original discrete system. The -1’s on the diagonal would be canceled out by adding the identity matrix, since discrete systems output the next state, not the difference between the current and next state.</p> <h3 id="finding-another-method-by-inverting-the-continuous-to-discrete-transformation">Finding another method by inverting the continuous-to-discrete transformation</h3> <p>Instead of doing something principled like the paper above, I decided to just try to directly convert a discrete-time linear system with delays into a continuous-time one. Thanks to Stack Exchange, I found that the bilinear transform is easily invertible<sup id="fnref:fn3" role="doc-noteref"><a href="#fn:fn3" class="footnote" rel="footnote">3</a></sup>. For some background, the bilinear transform is converts continous-time linear systems into discrete-time ones with what is essentially a trapezoidal approximation.</p> <p>Taking a discrete-time linear system with a delay, like the one shown in the very first section, we can apply the inverse bilinear transform to get a continuous-time system that should display the same behavior. Though I did not expect it to, it worked:</p> <p>[insert image here]</p> <p>Doing this a few times, there was a clear pattern to the resulting continuous-time systems. The dynamics of the delayed variable were always given by</p> \[\dot{y}(t) = -\dot{x}_{i}(t) + \frac{2}{\tau}(x_{i}(t) - y(t)).\] <p>This equation did not immediately make sense to me, but it’s actually quite straightforward if we rearrange it.</p> \[\dot{y}(t) + \dot{x}_{i}(t) = \frac{2}{\tau}(x_{i}(t) - y(t))\] \[\frac{\dot{y}(t) + \dot{x}_{i}(t)}{2} = \frac{x_{i}(t) - y(t)}{\tau}\] <p>If we assume the ideal of \(y(t) = x_{i}(t - \tau)\), we get</p> \[\frac{\dot{x}_{i}(t - \tau) + \dot{x}_{i}(t)}{2} = \frac{x_{i}(t) - x_{i}(t - \tau)}{\tau}.\] <p>Basically, the assumption of this method is that the average slope between \(x_{i}(t - \tau)\) and \(x_{i}(t)\) (aka the right-hand side of the equation) is exactly in between the slope at the left edge (aka \(\dot{x}_{i}(t - \tau)\)) and the slope at the right edge (aka \(\dot{x}(t)\)). This would be true if the second derivative were constant.</p> <p>The good thing about this approximation is that it retains all the benefits of the finite difference method, relying only on current observables and compensating for inaccurate initializations, while taking into account the additional information we know about \(\dot{x}_{i}(t)\) that was ignored by the finite difference method. Of course, this method also becomes more inaccurate as \(\tau\) grows, so the same partitioning of the delay used with the finite differences can still be used here, regardless of whether \(f\) is linear or non-linear.</p> <h3 id="generalizing-and-unifying-both-methods-with-taylor-expansions">Generalizing and unifying both methods with Taylor expansions</h3> <p>Seeing how the second method incorporates knowledge of \(\dot{x}(t)\) into the original estimate, you may have been reminded of Taylor expansions. Taylor expansions allow for the estimation of a function \(f\) at a point \(x'\) based on the value of \(f\), \(f'\), \(f''\), etc. at a reference point \(x\). Applying Taylor expansions to our problem, the estimation of \(\dot{x}_{i}(t - \tau)\), you’d get:</p> \[\dot{x}_{i}(t - \tau) = \dot{x}_{i}(t) + \frac{(-\tau)}{1!}\ddot{x}_{i}(t) + \frac{(-\tau)^2}{2!}x^{(3)}_{i}(t) + ...\] <p>where you would truncate the expansion at some term to get an approximation. However, this very clearly does not correspond to our previous methods. In particular, these approximations ignore the information in \(x(t)\) and \(y(t)\).</p> <p>But what do the values of \(x(t)\) and \(y(t)\) tell us? Again assuming the ideal that \(y(t) = x_{i}(t - \tau)\), then</p> \[x_{i}(t) - y(t) = x_{i}(t) - x_{i}(t - \tau) = \int_{t - \tau}^{t} \dot{x}_{i}(t^*) dt^*.\] <p>If we replace \(\dot{x}(t^*)\) in the integral with a Taylor approximation of \(\dot{x}(t^*)\), we can basically use the constraint to estimate one more term of the approximation without needing to compute the \(n+1\)-th derivative.</p> <p>Now for some algebra:</p> \[\begin{align*} x_{i}(t) - x_{i}(t - \tau) &amp;= \int_{t - \tau}^{t} \dot{x}_{i}(t^*) dt^* \\ &amp;= \int_{-\tau}^{0} \dot{x}_{i}(t + \tau^*) d\tau^* \\ &amp;= \int_{-\tau}^{0} d\tau^* \left(\dot{x}_{i}(t) + \frac{\tau^*}{1!}\ddot{x}_{i}(t) + \frac{(\tau^*)^2}{2!}x^{(3)}_{i}(t) + ... \right) \\ &amp;= \left[ \frac{\tau^*}{1!} \dot{x}_{i}(t) + \frac{(\tau^*)^2}{2!}\ddot{x}_{i}(t) + \frac{(\tau^*)^3}{3!}x^{(3)}_{i}(t) + ... \right]_{-\tau}^{0} \\ &amp;= - \left( \frac{(-\tau)}{1!} \dot{x}_{i}(t) + \frac{(-\tau)^2}{2!}\ddot{x}_{i}(t) + \frac{(-\tau)^3}{3!}x^{(3)}_{i}(t) + ... \right) \end{align*}\] <p>Now truncating the expansion at the \(n\)-th term and solving for the \(n + 1\)-th derivative, we get:</p> \[\begin{align*} x_{i}(t) - x_{i}(t - \tau) &amp;\approx - \left( \frac{(-\tau)}{1!} \dot{x}_{i}(t) + \frac{(-\tau)^2}{2!}\ddot{x}_{i}(t) + ... + \frac{(-\tau)^{n}}{n!}x^{(n)}_{i}(t) + \frac{(-\tau)^{n+1}}{(n+1)!} x^{(n+1)}_{i}(t) \right) \\ \frac{(-\tau)^{n+1}}{(n+1)!}x^{(n+1)}_{i}(t) &amp;\approx - \left( x_{i}(t) - x_{i}(t - \tau) + \frac{(-\tau)}{1!} \dot{x}_{i}(t) + \frac{(-\tau)^2}{2!}\ddot{x}_{i}(t) + ... + \frac{(-\tau)^{n}}{n!}x^{(n)}_{i}(t) \right) \\ x^{(n+1)}_{i}(t) &amp;\approx -\frac{(n + 1)!}{(-\tau)^{n+1}} \left( x_{i}(t) - x_{i}(t - \tau) + \frac{(-\tau)}{1!} \dot{x}_{i}(t) + \frac{(-\tau)^2}{2!}\ddot{x}_{i}(t) + ... + \frac{(-\tau)^{n}}{n!}x^{(n)}_{i}(t) \right) \end{align*}\] <p>Finally, plugging this back into the original Taylor approximation, we get:</p> \[\begin{align*} \dot{x}_{i}(t - \tau) &amp;\approx \dot{x}_{i}(t) + \frac{(-\tau)}{1!}\ddot{x}_{i}(t) + ... + \frac{(-\tau)^{n-1}}{n-1!}x^{(n)}_{i}(t) + \frac{(-\tau)^{n}}{n!}x^{(n+1)}_{i}(t) \\ &amp;= \dot{x}_{i}(t) + \frac{(-\tau)}{1!}\ddot{x}_{i}(t) + ... + \frac{(-\tau)^{n-1}}{n-1!}x^{(n)}_{i}(t) + \\ &amp;\quad \frac{(-\tau)^{n}}{n!} \cdot -\frac{(n + 1)!}{(-\tau)^{n+1}} \left( x_{i}(t) - x_{i}(t - \tau) + \frac{(-\tau)}{1!} \dot{x}_{i}(t) + ... + \frac{(-\tau)^{n}}{n!}x^{(n)}_{i}(t) \right) \\ &amp;= \dot{x}_{i}(t) + \frac{(-\tau)}{1!}\ddot{x}_{i}(t) + ... + \frac{(-\tau)^{n-1}}{n-1!}x^{(n)}_{i}(t) + \\ &amp;\quad \frac{n+1}{\tau} \left( x_{i}(t) - x_{i}(t - \tau) + \frac{(-\tau)}{1!} \dot{x}_{i}(t) + ... + \frac{(-\tau)^{n}}{n!}x^{(n)}_{i}(t) \right) \\ &amp;= \frac{n + 1}{\tau} (x_{i}(t) - x_{i}(t - \tau)) + \left(1 - \frac{n + 1}{1!}\right) \dot{x}_{i}(t) + ... + \left(\frac{1}{(n - 1)!} - \frac{n + 1}{n!}\right) (-\tau)^{n-1} x^{(n)}_{i}(t) \end{align*}\] <p>That was fun. Now, let’s look at the simplest approximation, for \(n = 0\). Plugging it in and ignoring all derivatives of order higher than \(0\) (i.e., all of them), we have:</p> \[\dot{x}_{i}(t - \tau) \approx \frac{0 + 1}{\tau} (x_{i}(t) - x_{i}(t - \tau)) = \frac{x_{i}(t) - x_{i}(t - \tau)}{\tau}\] <p>which looks a little familiar… Then, for \(n = 1\), we have:</p> \[\dot{x}_{i}(t - \tau) \approx \frac{1 + 1}{\tau} (x_{i}(t) - x_{i}(t - \tau)) + \left(1 - \frac{1 + 1}{1!}\right) \dot{x}_{i}(t) = \frac{2}{\tau} (x_{i}(t) - x_{i}(t - \tau)) - \dot{x}_{i}(t).\] <p>So, the last two methods were all specific cases of this constrained Taylor approximation. We can arbitrarily increase the degree of this approximation as long as we can compute \(x^{(n - 1)}_{i}(t)\), which in general is not particularly easy but is very tractable for linear systems.</p> <h3 id="evaluating-the-methods">Evaluating the methods</h3> <p>TODO</p> <h3 id="references">References</h3> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:fn1" role="doc-endnote"> <p>Sun, Jian-Qiao. A method of continuous time approximation of delayed dynamical systems. In <em>Communications in Nonlinear Science and Numerical Simulation</em>, 2009. <a href="https://www.sciencedirect.com/science/article/pii/S1007570408000610" rel="external nofollow noopener" target="_blank">URL</a> <a href="#fnref:fn1" class="reversefootnote" role="doc-backlink">↩</a> <a href="#fnref:fn1:1" class="reversefootnote" role="doc-backlink">↩<sup>2</sup></a></p> </li> <li id="fn:fn2" role="doc-endnote"> <p>Butcher, Eric A. and Bobrenkov, Oleg A. On the Chebyshev spectral continuous time approximation for constant and periodic delay differential equations. In <em>Communications in Nonlinear Science and Numerical Simulation</em>, 2011. <a href="https://www.sciencedirect.com/science/article/pii/S1007570410003539" rel="external nofollow noopener" target="_blank">URL</a> <a href="#fnref:fn2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:fn3" role="doc-endnote"> <p>van der Veen, Kwin. discrete-time to continuous-time state space. On <em>Mathematics Stack Exchange</em>, 2020. <a href="https://math.stackexchange.com/q/3820405" rel="external nofollow noopener" target="_blank">URL</a> <a href="#fnref:fn3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Felix Pei. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>